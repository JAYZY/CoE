程序分为两类 linked Tri(LT)以及 Extend Tri(ET)
日志记录


9-10

1.针对 ET 改进如下：
（1） 优化 UnitDeduct 单元约减中 添加条件-“若下拉文字没有发生变元替换则不进行规则检查”；  【已实现】
（2）对生成的新子句，实现factor rule（因子规则）  [已实现] -- 对CSR026+3.p 无用
感觉 factor 效果并不明显
（3） △生成新子句，放入子句集，然后选择最优的子句使用。[已实现]
 
（4）怎样避免 同一个子句中不同文字 优先被同一个主界线文字下拉（或同一个单元文字下拉）【已实现】
（5）对主界线进行排序   【已实现】
（6）输出完整的拓展三角形 【基本实现】


1. 针对 LT 需要做的改进：
（1）添加 factor rule(因子规则) 
（2）修改单元下拉full模式为回退模式 [修改后的算法：] 单元子句下拉，完全下拉
（3）修改单元子句索引模式 

------
Idea: 为了避免重复演绎路径，记录某个子句单元下拉索引位置。（始终保证所有单元子句不排序）
1. 对每一个起步的非单元子句，获取单元下拉位置pos,并从该位置开始查找单元下拉。
2. 记录第一个文字，所有单元下拉全部查找完毕，则记录。
3. 问题： 若第一个文字 没有匹配的下拉？也做记录 最后一个位置（万一后续新单元子句有可以下拉的呢？）


两种方法：回退方式 和全路径方法 

10.5

1.优化了单元子句充分下拉函数，修改了保留最好演绎中的 替换的bug
2.删除 核心函数中对剩余文字函数嵌套层的判断。问题，一个文字超过函数层限制，可以作为延拓文字，被删除（这是对的）但是当子句中所有文字全部超过函数层限制，
则A.该新子句不加入S中。B.回退上一步演绎路径

10.7 对比例子 CSR029+3 扩展和标准延拓两个方法的结果发现
区别在于。 起步子句7201 （二元）第一次演绎后得到的结果还可以用该子句继续演绎。但是再用到该子句起步不知道要等多久。。。导致时间不足
修改IDEA: 起步子句只从规定文字个数 子句起步 ？


想法： 
1. 目前亟待解决的问题在于  重命名单元子句的保存问题。 应该改为 只要有输出就不要保留。
2. 保留单元下拉中 所有满足 newR限制的子句（目前只保留单元子句，为什么不保留2个 或 3个文字的子句呢？）--- 后续解决
3. 考虑一个问题 是否可以允许 子句重复使用问题 当主动文字 查找 被动文字发现是自己子句 可以重复使用1次



10.10 
1. 修改了factor rule  
2. 针对自归结问题 进行了思考与改进；
算法思路： 当一个子句产生单文字子句时候，与该子句本身进行归结，归结的结果再与所有单元子句进行下拉归结。
         注意只保留单文字子句的结果。