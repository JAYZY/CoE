
1.varbank实现对变量的存储 主要采用两个属性:
一个动态数组用于存储 项指针(TermCell)
一个扩展树 用于存储 字符串到项指针的索引

2.思考: 是否可以将 Indexing Tree 与 Term存储树 结构相结合 ?

3.改进思路.结合ME对三角形进行改进.完成对回退功能的改进

一. 实现步骤
注意全局 变元存储到 
1. 预处理模块 -- 将S 中的文字 放入 B集合中 
A.完成 单元子句链初始化
B.



调试命令 
 cd ~/Documents/myProg/CoE/CoProver/dist/Debug/GNU-Linux/

 ./coprover //home/icdc/testTxt/CADE2017/COM145+1+short+eq_rstfp.tptp >>2.txt
 ./coprover /home/icdc/Problems/CASC-J9-2017/CNF-FNN/FNN-SYN422+1.p  >>1.txt

二.完成三角形中遇到的问题
1. 将一个子句Ci加入到三角形中后,是先检查下拉(reduce)还是 最后完成三角形再检查下拉?
A.边做边检查下拉,则有可能导致主界线文字过早的实例化. 后续子句无法归结.
B.最后检查下拉,则有可能导致  前面剩余文字中  可以下拉的文字 无法下拉.  

最后选择策略：在构建△过程中，下拉操作不做合一操作。当△构建完成，生成R的时候统一进行一次 合一下拉操作
可能导致的问题在于，对R文字数的判定会存在不准确的问题。-- 解决思路，对延拓三角形判定的时候可以放宽R限制

2.△延拓遵循的原则是什么？
A.△尽可能的延拓 B.R的剩余文字尽可能的少

3.单元子句充分下拉算法（选定子句为 Ci）
A.若第一个检查的文字Li 为基文字或无公共变元 是不需要多次下拉匹配的。
因此，基文字和无公共变元文字只需要检查下拉就可以了（排序在最后）
B.有公共变元的文字Li' ==>




4.三角形无法延伸分2种情况
A.最后一个子句中的剩余文字 均 找不到互补文字进行延续
B.最后一个子句中的剩余文字不满足设定的规则 a）剩余文字个数超过限制；b)
最后一个子句中没有剩余文字,(平顶)
目前主要的优化 在于 平顶的时候,采用truncation 操作 生成一些 单元子句.

5.生成新子句的函数包括
(1) 读取文本时 
      ClauseParse(Scanner* in) ==> EqnListParse(TokenType sep) ==> Literal(Scanner* in, int litPos, Cla_p cla) 
(2) 生成新子句时
    2.1 单元子句复制
        bindingLits(Literal* litLst) ==> 
    2.2 剩余文字R 生成新子句 
        RenameCopy(newCla);  
         bindingLits(Literal* litLst)
    2.3 Factor 删除文字时
        bindingAndRecopyLits
 
$weight_max = Q(s_t)/N(s_t)+ 2C \sqrt{2*lnN(s_{t-1}}/N(s_t))$

//考虑1 先记录 重用单元子句 后面统一输出 !??!?!?  P2941   P3018 Unsat 输出
//考虑2 改变子句中文字顺序  是采用精准下标控制,还是采用权重排序的方式 ????? P3208
6. 权重修改记录
A. 单元子句下拉 A = ~A  若 A 所在子句剩余文字有冗余,则说明 该下拉变元替换导致冗余产生 主动文字和单元子句文字 qulity均-1; P2881
B. 


曹峰 子句重用问题 f (copyClaCopyTimes(cpClaTmp) <= StrategyParam::claReUseTimes) P1558 TriAlg