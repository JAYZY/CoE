/*
 * 替换类 substitutions
 * File:   Subst.h
 * Author: zj 
 *
 * Created on 2017年3月25日, 下午3:36
 */

#ifndef SUBST_H
#define SUBST_H
#include "TERMS/TermCell.h"
#include "TERMS/VarBank.h"

class Subst {
private:
    vector<TermCell*> vecSubst; //替换列表
public:
    Subst();
    Subst(const Subst& orig);
    virtual ~Subst();
public:
    /*---------------------------------------------------------------------*/
    /*                       inline Function                               */

    /*---------------------------------------------------------------------*/
    inline uint32_t Size() {
        return vecSubst.size();
    }

    inline void Clear() {
        int s = vecSubst.size();
        int icount = SubstBacktrack();
        assert(s == icount);
        vecSubst.clear();
    }
    /*---------------------------------------------------------------------*/
    /*                  Member Function-[public]                           */
    /*---------------------------------------------------------------------*/
    int SubstAddBinding(TermCell* var, TermCell* bind);

    /* Backtrack a single binding and remove it from the substitution (if possible). 
     * Return true if successful, false if the substitutuion is empty. */
    bool SubstBacktrackSingle();

    /* 回滚替换变元,直到给定的位置pos -- Backtrack variable bindings up to (down to?) a given stack pointer position. */
    int SubstBacktrackToPos(int pos);

    /* Undo all stored variable binding in subst. */
    int SubstBacktrack();

    /* Instatiate all variables in term with fresh variables from the VarBank. 
     * Return old value of vars->v_count, so VarBankSetVCount() and 
     * SubstBacktrackToPos() can be used to backtrack the instatiations term by term.
     * New variables are marked by TPSpecialFlag, 
     * if other variables are marked thus the effect is unpredictable.
     * Warning: As variables may be shared, other terms may be affected!
     * Take care...your best bet is to norm all terms you need with a single substitution. 
     * If you need independendly normed terms, you need to work 
     * with copy/backtrack operations (it's still better than working with unshared terms). */
    FunCode SubstNormTerm(TermCell* term, VarBank_p vars);

    /* Print a variable and its binding as x<-binding. Return true if variable is bound. 
     * See comments on SubstPrint()! */
    bool SubstBindingPrint(FILE* out, TermCell* var, DerefType deref);

    /* Print a substitution. Note: Due to the different interpretations of terms 
     * (follow/ignore bindings) and share variable, printing substitutions 
     * with deref=DEREF_ALWAYS may lead to unpredictable behaviour 
     * (if e.g. the substitution was generated by matching x onto f(x)). 
     * Returns number of variables in subst (well, why not...). */
    long SubstPrint(FILE* out, DerefType deref);

    /* Return true if subst is just a variable renaming, false otherwise. 
     * A substitution is a renaming if all variables are instantiated 
     * to different variables. Checks only for one level of instantiaton.
     * 
     * Changes the TPOpFlag of terms */
    bool SubstIsRenaming();

    /* Backtrack a skolem subst, freeing the skolem terms along the way. */
    void SubstBacktrackSkolem();

    /* Instantiate all variables in term with new skolem symbols from  sig. */
    void SubstSkolemizeTerm(TermCell* term, Sig_p sig);

    /* Add bindings for all free variables in term subst, binding them to default_term. 
     * result: Changes subst */
    void SubstCompleteInstance(TermCell* term, TermCell* defaultBinding);

};
typedef Subst *Subst_p/*替换类 substitutions*/;

#endif /* SUBST_H */

